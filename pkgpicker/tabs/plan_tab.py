from __future__ import annotations

import csv
import os
import subprocess
import threading
import time
from typing import Any, Dict, List, Optional, Set, Tuple

from textual.containers import Container, Horizontal, Vertical
from textual.widgets import Button, DataTable, Static

from ..arch import which, run_capture, pacman_repo_has, aur_has_yay
from ..history import log_history
from ..modals import TextInputModal
from ..cache import save_json, load_json_safe
from ..models import ConflictRule

# -------- configs generators --------
def greetd_config(cmd: str) -> str:
    return f"""# Generated by pkgpicker
[terminal]
vt = 1

[default_session]
command = "tuigreet --time --remember --cmd {cmd}"
user = "greeter"
"""

def hypr_conf() -> str:
    return r"""# Generated by pkgpicker (Hyprland starter)
$mod = SUPER
env = MOZ_ENABLE_WAYLAND,1
env = QT_QPA_PLATFORM,wayland
env = SDL_VIDEODRIVER,wayland

exec-once = dbus-update-activation-environment --systemd WAYLAND_DISPLAY XDG_CURRENT_DESKTOP
exec-once = systemctl --user import-environment WAYLAND_DISPLAY XDG_CURRENT_DESKTOP
exec-once = waybar
exec-once = mako
exec-once = hyprpaper
exec-once = wl-paste --type text --watch cliphist store
exec-once = wl-paste --type image --watch cliphist store

input {
  kb_layout = de
}

bind = $mod, Return, exec, kitty
bind = $mod, D, exec, wofi --show drun
bind = $mod, V, exec, cliphist list | wofi --dmenu | cliphist decode | wl-copy
bind = $mod, S, exec, grim -g "$(slurp)" - | wl-copy
"""

def waybar_jsonc() -> str:
    return r"""{
  "layer":"top","position":"top","height":30,
  "modules-left":["hyprland/workspaces","hyprland/window"],
  "modules-center":["clock"],
  "modules-right":["pulseaudio","network","battery","tray"],
  "clock":{"format":"{:%a %d.%m %H:%M}"},
  "pulseaudio":{"format":" {volume}%","on-click":"pavucontrol"},
  "network":{"format-wifi":" {essid}","format-ethernet":" {ipaddr}","format-disconnected":" offline"}
}"""

def mako_conf() -> str:
    return "default-timeout=5000\n"

def wofi_style() -> str:
    return "/* Generated by pkgpicker */\nwindow { border-radius: 10px; }\n"

# -------- conflict helpers --------
def conflict_problems(selected: Set[str], rules: List[ConflictRule]) -> List[str]:
    probs: List[str] = []
    for r in rules:
        present = [p for p in r.group if p in selected]
        if r.mode == "exactly_one":
            if len(present) != 1:
                probs.append(f"{r.name}: erwartet genau 1, aktuell: {present if present else 'none'}")
        else:
            if len(present) > 1:
                probs.append(f"{r.name}: zu viele ausgewählt: {present}")
    return probs

# -------- UI --------
def build(app, pane):
    app.mount_topcard(
        pane,
        "Plan",
        "Install/Remove/Services/Presets + Apply",
        "i Apply · q QuickAdd · p SaveProfile · l LoadProfile",
    )

    row = Horizontal(id="plan_row")
    pane.mount(row)

    # left: plan tables
    left = Vertical(id="plan_left")
    row.mount(Container(left, id="plan_left_wrap"))

    tbl_add = DataTable(id="plan_add_tbl")
    app.safe_cursor_row(tbl_add)
    tbl_add.add_columns("Pkg", "Src", "Inst")

    tbl_rm = DataTable(id="plan_rm_tbl")
    app.safe_cursor_row(tbl_rm)
    tbl_rm.add_columns("Pkg", "Inst?")

    tbl_svc = DataTable(id="plan_svc_tbl")
    app.safe_cursor_row(tbl_svc)
    tbl_svc.add_columns("Unit", "Action")

    left.mount(Static("[b]To Install[/b]", classes="infobox"))
    left.mount(tbl_add)
    left.mount(Static("[b]To Remove (explicit)[/b]", classes="infobox"))
    left.mount(tbl_rm)
    left.mount(Static("[b]Services Plan[/b]", classes="infobox"))
    left.mount(tbl_svc)

    # right: preview/info
    pane.mount(Static("", id="plan_info", classes="infobox"))

    pane.mount(
        Horizontal(
            Button("Selection → Plan (a)", id="btn_plan_addsel", variant="success"),
            Button("Clear Plan", id="btn_plan_clear", variant="warning"),
            Button("Apply (i)", id="btn_plan_apply", variant="primary"),
            Button("Save Profile (p)", id="btn_profile_save", variant="success"),
            Button("Load Profile (l)", id="btn_profile_load", variant="primary"),
            classes="toolbar",
        )
    )

    refresh(app)

def refresh(app):
    _populate_plan_tables(app)
    _update_info(app)

def _populate_plan_tables(app):
    tbl = app.query_one("#plan_add_tbl", DataTable)
    tbl.clear(columns=True)
    tbl.add_columns("Pkg", "Src", "Inst")
    allp = []
    for p in sorted(app.plan_repo):
        allp.append((p, "repo"))
    for p in sorted(app.plan_aur):
        allp.append((p, "aur"))
    for p, src in allp:
        inst = "✔" if p in app.installed_all else ""
        tbl.add_row(p, src, inst, key=f"{src}:{p}")

    trm = app.query_one("#plan_rm_tbl", DataTable)
    trm.clear(columns=True)
    trm.add_columns("Pkg", "Inst?")
    for p in sorted(app.remove_explicit):
        inst = "✔" if p in app.installed_all else ""
        trm.add_row(p, inst, key=p)

    tsvc = app.query_one("#plan_svc_tbl", DataTable)
    tsvc.clear(columns=True)
    tsvc.add_columns("Unit", "Action")
    for u in sorted(app.plan_services_enable):
        tsvc.add_row(u, "enable", key=f"en:{u}")
    for u in sorted(app.plan_services_disable):
        tsvc.add_row(u, "disable", key=f"dis:{u}")

def _update_info(app):
    box = app.query_one("#plan_info", Static)
    t = app.current_target()
    combined = set(app.installed_all) | app.plan_repo | app.plan_aur
    probs = conflict_problems(combined, app.conflicts)
    lines = [
        f"[b]Target[/b]: {t.name}",
        f"[b]Plan Install[/b]: repo={len(app.plan_repo)} aur={len(app.plan_aur)}",
        f"[b]Plan Remove[/b]: {len(app.remove_explicit)}",
        f"[b]Services[/b]: +{len(app.plan_services_enable)} -{len(app.plan_services_disable)}",
        f"[b]Preset[/b]: {app.plan_preset or '-'} · configs: {'YES' if app.plan_generate_configs else 'no'}",
    ]
    if probs:
        lines.append("")
        lines.append("[b]Conflicts[/b]:")
        for p in probs[:12]:
            lines.append(f"- {p}")
        if len(probs) > 12:
            lines.append(f"... +{len(probs)-12} more")
    box.update("\n".join(lines))
    app.update_status()

# -------- selection → plan --------
def add_selection_to_plan(app):
    app.plan_repo |= set(app.selected_repo)
    app.plan_aur |= set(app.selected_aur)
    app.selected_repo.clear()
    app.selected_aur.clear()
    try:
        from . import packages_tab
        packages_tab.refresh(app)
    except Exception:
        pass
    refresh(app)
    app.set_last("Selection → Plan")

# -------- profiles --------
def _profile_path(app, name: str) -> str:
    safe = "".join([c for c in name if c.isalnum() or c in ("-", "_")]).strip("_-")
    if not safe:
        safe = "profile"
    return os.path.join(app.PROFILES_DIR, f"{safe}.json")

async def profile_save(app):
    name = await app.push_result(TextInputModal("Profile Save", "profile name…"))
    name = (name or "").strip()
    if not name:
        app.set_last("Profile save cancelled")
        return
    path = _profile_path(app, name)
    obj = {
        "plan_repo": sorted(app.plan_repo),
        "plan_aur": sorted(app.plan_aur),
        "remove_explicit": sorted(app.remove_explicit),
        "svc_enable": sorted(app.plan_services_enable),
        "svc_disable": sorted(app.plan_services_disable),
        "preset": app.plan_preset,
        "gen_configs": app.plan_generate_configs,
        "saved_at": time.strftime("%Y-%m-%d %H:%M:%S"),
    }
    save_json(path, obj)
    app.set_last(f"Profile saved: {os.path.basename(path)}")
    app.show_output("Profile saved", f"Saved to:\n{path}")

async def profile_load(app):
    # pick latest if no picker UI yet → load by name
    name = await app.push_result(TextInputModal("Profile Load", "profile name (without .json)…"))
    name = (name or "").strip()
    if not name:
        app.set_last("Profile load cancelled")
        return
    path = _profile_path(app, name)
    obj = load_json_safe(path, None)
    if not isinstance(obj, dict):
        app.show_output("Profile load", f"Not found or invalid:\n{path}")
        return
    app.plan_repo = set(obj.get("plan_repo", []) or [])
    app.plan_aur = set(obj.get("plan_aur", []) or [])
    app.remove_explicit = set(obj.get("remove_explicit", []) or [])
    app.plan_services_enable = set(obj.get("svc_enable", []) or [])
    app.plan_services_disable = set(obj.get("svc_disable", []) or [])
    app.plan_preset = obj.get("preset") or None
    app.plan_generate_configs = bool(obj.get("gen_configs", False))
    refresh(app)
    app.set_last(f"Profile loaded: {os.path.basename(path)}")

# -------- quick add --------
async def quick_add(app):
    val = await app.push_result(TextInputModal("Quick Add", "package name (repo or aur)…"))
    pkg = (val or "").strip()
    if not pkg:
        app.set_last("QuickAdd cancelled")
        return

    # smart source detect
    src = None
    if pacman_repo_has(pkg):
        src = "repo"
    elif aur_has_yay(pkg):
        src = "aur"
    else:
        # fallback: treat as repo first, then aur; user can fix later
        src = "repo" if not which("yay") else "aur"

    if src == "aur":
        app.plan_aur.add(pkg)
        app.plan_repo.discard(pkg)
    else:
        app.plan_repo.add(pkg)
        app.plan_aur.discard(pkg)

    refresh(app)
    app.set_last(f"QuickAdd: {pkg} ({src})")

# -------- apply plan --------
def _run_cmd_live(cmd: List[str]) -> Tuple[int, str]:
    rc, out = run_capture(cmd)
    return rc, out

def _apply_worker(app) -> None:
    app.call_from_thread(app.set_busy, "Applying plan … (sudo may ask password)")
    cmds_run: List[str] = []
    out_chunks: List[str] = []
    rc_final = 0

    def run_and_collect(cmd: List[str]) -> int:
        nonlocal rc_final
        cmds_run.append(" ".join(cmd))
        rc, out = _run_cmd_live(cmd)
        out_chunks.append(f"$ {' '.join(cmd)}\n{out}\n")
        if rc != 0 and rc_final == 0:
            rc_final = rc
        return rc

    # 1) conflict check
    combined = set(app.installed_all) | app.plan_repo | app.plan_aur
    probs = conflict_problems(combined, app.conflicts)
    if probs:
        app.call_from_thread(app.set_busy, "")
        app.call_from_thread(app.show_output, "Conflicts", "\n".join(probs))
        app.call_from_thread(app.set_last, "Apply aborted: conflicts")
        return

    # 2) removals (explicit only)
    if app.remove_explicit:
        rm = sorted(app.remove_explicit)
        run_and_collect(["sudo", "pacman", "-Rns", "--noconfirm"] + rm)

    # 3) repo installs
    if app.plan_repo:
        pkgs = sorted(app.plan_repo)
        run_and_collect(["sudo", "pacman", "-S", "--needed", "--noconfirm"] + pkgs)

    # 4) AUR installs
    if app.plan_aur:
        if not which("yay"):
            out_chunks.append("ERROR: yay not installed, cannot install AUR.\n")
            rc_final = rc_final or 2
        else:
            pkgs = sorted(app.plan_aur)
            run_and_collect(["yay", "-S", "--needed", "--noconfirm"] + pkgs)

    # 5) services apply
    for u in sorted(app.plan_services_enable):
        run_and_collect(["sudo", "systemctl", "enable", "--now", u])
    for u in sorted(app.plan_services_disable):
        run_and_collect(["sudo", "systemctl", "disable", "--now", u])

    # 6) presets/config generator
    if app.plan_generate_configs and app.plan_preset:
        ok, msg = _generate_configs(app)
        out_chunks.append(msg + "\n")
        if not ok:
            rc_final = rc_final or 3

    # history log
    log_history(app.HISTORY_LOG, "apply", cmds_run, rc_final)

    # refresh state
    app.call_from_thread(app.refresh_all)
    app.call_from_thread(app.set_busy, "")
    app.call_from_thread(refresh, app)

    # output
    app.call_from_thread(
        app.show_output,
        "Apply result",
        f"rc={rc_final}\n\n" + ("\n".join(out_chunks)[-18000:]),
    )
    app.call_from_thread(app.set_last, f"Apply done (rc={rc_final})")

def _generate_configs(app) -> Tuple[bool, str]:
    from ..arch import sudo_write_file, backup_write_user
    lines = ["Config generation:"]
    ok = True

    # greetd
    if app.plan_preset == "hyprland-tuigreet":
        rc = sudo_write_file("/etc/greetd/config.toml", greetd_config("Hyprland"))
        lines.append(f"- /etc/greetd/config.toml (Hyprland): rc={rc}")
        ok = ok and (rc == 0)
        p1 = backup_write_user("~/.config/hypr/hyprland.conf", hypr_conf())
        lines.append(f"- {p1}")
        p2 = backup_write_user("~/.config/waybar/config", waybar_jsonc())
        lines.append(f"- {p2}")
        p3 = backup_write_user("~/.config/mako/config", mako_conf())
        lines.append(f"- {p3}")
        p4 = backup_write_user("~/.config/wofi/style.css", wofi_style())
        lines.append(f"- {p4}")
    elif app.plan_preset == "plasma-tuigreet":
        rc = sudo_write_file("/etc/greetd/config.toml", greetd_config("startplasma-wayland"))
        lines.append(f"- /etc/greetd/config.toml (Plasma Wayland): rc={rc}")
        ok = ok and (rc == 0)
    else:
        lines.append("- unknown preset (skip)")

    return ok, "\n".join(lines)

async def apply_plan(app):
    # confirmation summary
    lines = []
    if app.plan_repo: lines.append(f"Install repo: {len(app.plan_repo)}")
    if app.plan_aur: lines.append(f"Install AUR: {len(app.plan_aur)}")
    if app.remove_explicit: lines.append(f"Remove: {len(app.remove_explicit)}")
    if app.plan_services_enable or app.plan_services_disable:
        lines.append(f"Services: +{len(app.plan_services_enable)} -{len(app.plan_services_disable)}")
    if app.plan_generate_configs and app.plan_preset:
        lines.append(f"Generate configs: {app.plan_preset}")
    if not lines:
        app.show_output("Apply", "Plan ist leer.")
        return

    ok = await app.ask_confirm("Apply Plan", "Wirklich ausführen?\n\n" + "\n".join(lines))
    if not ok:
        app.set_last("Apply cancelled")
        return

    threading.Thread(target=_apply_worker, args=(app,), daemon=True).start()

# -------- Plan actions --------
def action_toggle(app) -> bool:
    # allow toggling remove list from plan_rm_tbl
    try:
        if app.query_one("#plan_rm_tbl").has_focus:
            tbl = app.query_one("#plan_rm_tbl", DataTable)
            if not tbl.row_count:
                return True
            p = str(tbl.get_row_at(tbl.cursor_row)[0])
            if p in app.remove_explicit: app.remove_explicit.remove(p)
            else: app.remove_explicit.add(p)
            _populate_plan_tables(app)
            _update_info(app)
            return True
        if app.query_one("#plan_add_tbl").has_focus:
            tbl = app.query_one("#plan_add_tbl", DataTable)
            if not tbl.row_count:
                return True
            row = tbl.get_row_at(tbl.cursor_row)
            pkg, src = str(row[0]), str(row[1])
            if src == "aur":
                if pkg in app.plan_aur: app.plan_aur.remove(pkg)
                else: app.plan_aur.add(pkg)
            else:
                if pkg in app.plan_repo: app.plan_repo.remove(pkg)
                else: app.plan_repo.add(pkg)
            _populate_plan_tables(app)
            _update_info(app)
            return True
    except Exception:
        return False
    return False

def action_info(app) -> bool:
    return False

def on_row_highlighted(app, event, table_id: str) -> bool:
    return table_id in ("plan_add_tbl", "plan_rm_tbl", "plan_svc_tbl")

async def on_button(app, bid: str) -> bool:
    if bid == "btn_plan_addsel":
        add_selection_to_plan(app)
        return True
    if bid == "btn_plan_clear":
        ok = await app.ask_confirm("Clear Plan", "Plan wirklich leeren?")
        if ok:
            app.plan_repo.clear()
            app.plan_aur.clear()
            app.remove_explicit.clear()
            app.plan_services_enable.clear()
            app.plan_services_disable.clear()
            app.plan_preset = None
            app.plan_generate_configs = False
            refresh(app)
            app.set_last("Plan cleared")
        return True
    if bid == "btn_plan_apply":
        await apply_plan(app)
        return True
    if bid == "btn_profile_save":
        await profile_save(app)
        return True
    if bid == "btn_profile_load":
        await profile_load(app)
        return True
    return False

